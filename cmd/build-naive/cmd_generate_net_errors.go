package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"unicode"

	"github.com/spf13/cobra"
)

var commandGenerateNetErrors = &cobra.Command{
	Use:   "generate-net-errors",
	Short: "Generate Go error constants from Chromium's net_error_list.h",
	Run:   runGenerateNetErrors,
}

func init() {
	mainCommand.AddCommand(commandGenerateNetErrors)
}

type netErrorEntry struct {
	name        string
	code        int
	description string
	message     string
}

func runGenerateNetErrors(cmd *cobra.Command, args []string) {
	sourceFile := filepath.Join(srcRoot, "net", "base", "net_error_list.h")
	outputFile := filepath.Join(projectRoot, "net_error_generated.go")

	errors, err := parseNetErrorList(sourceFile)
	if err != nil {
		log.Fatalf("failed to parse %s: %v", sourceFile, err)
	}

	err = generateNetErrorGoFile(errors, outputFile)
	if err != nil {
		log.Fatalf("failed to generate %s: %v", outputFile, err)
	}

	log.Printf("generated %s with %d error codes", outputFile, len(errors))
}

var netErrorRegex = regexp.MustCompile(`NET_ERROR\(\s*(\w+)\s*,\s*(-?\d+)\s*\)`)

func parseNetErrorList(filename string) ([]netErrorEntry, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var errors []netErrorEntry
	var commentLines []string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		if strings.HasPrefix(trimmed, "//") {
			comment := strings.TrimPrefix(trimmed, "//")
			comment = strings.TrimSpace(comment)
			if !strings.Contains(comment, "no-include-guard") &&
				!strings.Contains(comment, "NOLINT") &&
				comment != "" {
				commentLines = append(commentLines, comment)
			}
			continue
		}

		if matches := netErrorRegex.FindStringSubmatch(line); matches != nil {
			name := matches[1]
			code, _ := strconv.Atoi(matches[2])

			if strings.HasSuffix(name, "_END") {
				commentLines = nil
				continue
			}

			description := buildNetErrorDescription(commentLines)
			message := netErrorNameToMessage(name)

			errors = append(errors, netErrorEntry{
				name:        name,
				code:        code,
				description: description,
				message:     message,
			})
			commentLines = nil
			continue
		}

		if trimmed == "" || (!strings.HasPrefix(trimmed, "//") && !strings.HasPrefix(trimmed, "NET_ERROR")) {
			if trimmed != "" && !strings.HasPrefix(trimmed, "#") {
				commentLines = nil
			}
		}
	}

	return errors, scanner.Err()
}

func buildNetErrorDescription(comments []string) string {
	if len(comments) == 0 {
		return ""
	}

	var filtered []string
	for _, c := range comments {
		if strings.HasPrefix(c, "Ranges:") ||
			regexp.MustCompile(`^\d+-\d+\s+`).MatchString(c) ||
			strings.HasPrefix(c, "0-") {
			continue
		}
		if strings.Contains(c, "was removed") {
			continue
		}
		if strings.Contains(c, "is reserved") {
			continue
		}
		filtered = append(filtered, c)
	}

	return strings.Join(filtered, " ")
}

func netErrorNameToMessage(name string) string {
	words := strings.Split(strings.ToLower(name), "_")
	if len(words) > 0 && words[0] == "err" {
		words = words[1:]
	}
	return strings.Join(words, " ")
}

func netErrorNameToGoName(name string) string {
	parts := strings.Split(strings.ToLower(name), "_")
	var result strings.Builder
	for _, part := range parts {
		if part == "" {
			continue
		}
		switch strings.ToUpper(part) {
		case "IO", "IP", "SSL", "TLS", "HTTP", "DNS", "URL", "TCP", "UDP", "QUIC", "CT", "PAC", "PKCS", "RST", "FIN", "ACK", "SOCKS", "MAC", "DH", "ECH", "CSP", "ORB":
			result.WriteString(strings.ToUpper(part))
		case "HTTP2":
			result.WriteString("HTTP2")
		default:
			runes := []rune(part)
			runes[0] = unicode.ToUpper(runes[0])
			result.WriteString(string(runes))
		}
	}
	return result.String()
}

func generateNetErrorGoFile(errors []netErrorEntry, filename string) error {
	var buffer bytes.Buffer

	buffer.WriteString(`// Code generated by cmd/build-naive generate-net-errors. DO NOT EDIT.
// Source: naiveproxy/src/net/base/net_error_list.h

package cronet

// NetError constants from Chromium's net_error_list.h
const (
`)

	for _, entry := range errors {
		goName := "NetError" + netErrorNameToGoName(entry.name)
		buffer.WriteString(fmt.Sprintf("\t%s NetError = %d\n", goName, entry.code))
	}

	buffer.WriteString(`)

type netErrorEntry struct {
	name        string
	message     string
	description string
}

var netErrorInfo = map[NetError]netErrorEntry{
`)

	for _, entry := range errors {
		goName := "NetError" + netErrorNameToGoName(entry.name)
		name := fmt.Sprintf("ERR_%s", entry.name)
		buffer.WriteString(fmt.Sprintf("\t%s: {%q, %q, %q},\n", goName, name, entry.message, entry.description))
	}

	buffer.WriteString(`}
`)

	formatted, err := format.Source(buffer.Bytes())
	if err != nil {
		os.WriteFile(filename+".unformatted", buffer.Bytes(), 0o644)
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	return os.WriteFile(filename, formatted, 0o644)
}
